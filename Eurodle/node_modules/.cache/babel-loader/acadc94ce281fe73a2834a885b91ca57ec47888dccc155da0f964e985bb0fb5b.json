{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\mpord\\\\Documents\\\\3IngSoft\\\\2Cuatri\\\\IU\\\\UserInterfacesProject\\\\Eurodle\\\\src\\\\guessSong\\\\ExtraClues.js\";\nimport React from \"react\";\nimport YouTubePlayer from './YouTubePlayer'; // Adjust the import path\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst ExtraClues = ({\n  songData,\n  fallos,\n  acertado\n}) => {\n  var _songData$song_name, _songData$song_name2;\n  if (!songData) return null;\n  const minStart = 6;\n  const startTime = Math.floor(Math.random() * (100 - minStart)) + minStart;\n\n  // Extract video ID from YouTube URL\n  const getVideoId = url => {\n    if (!url) return '';\n    const match = url.match(/(?:youtu\\.be\\/|youtube\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=))([^?&]+)/i);\n    return match && match[1] ? match[1] : '';\n  };\n  const videoId = getVideoId(songData.youtube_url);\n  const pistasDisponibles = [`Ranking final: ${\"la canción quedó en el puesto \" + songData.final_place}`, `${\"la canción quedó\" + (songData.paisAbajo === \"Desconocido\" ? \"\" : \" por encima de \" + songData.paisAbajo) + (songData.paisAbajo === \"Desconocido\" || songData.paisArriba === \"Desconocido\" ? \"\" : \" y \") + (songData.paisArriba === \"Desconocido\" ? \"\" : \"y por debajo de \" + songData.paisArriba)}`, `${\"El idioma del tema es: \" + songData.language + \" y el género: \" + songData.style}`, `El nombre de la canción empieza con la letra: ${(_songData$song_name = songData.song_name) === null || _songData$song_name === void 0 ? void 0 : _songData$song_name.charAt(0)} y termina con: ${(_songData$song_name2 = songData.song_name) === null || _songData$song_name2 === void 0 ? void 0 : _songData$song_name2.slice(-1)}`, `Fragmento de la letra: ${obtenerFragmentoOptimizado(songData.lyrics)}`, `${\"Nombre del/los artista/s o del grupo: \" + songData.artist_name}`, {\n    type: 'component',\n    component: /*#__PURE__*/_jsxDEV(YouTubePlayer, {\n      videoId: videoId,\n      startTime: startTime\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 35,\n      columnNumber: 41\n    }, this)\n  }];\n  function obtenerFragmentoOptimizado(texto, minLong = 70, maxLong = 100, intentos = 10) {\n    const limpio = texto.replace(/(\\\\n\\s*){1,}/g, \", \") // Agrupa 1 o más \\n seguidos como una coma\n    .replace(/\\s+/g, \" \") // Normaliza los espacios\n    .trim();\n    const palabras = limpio.split(\" \");\n    const totalPalabras = palabras.length;\n    for (let i = 0; i < intentos; i++) {\n      let inicio = Math.floor(Math.random() * totalPalabras);\n      let fragmento = \"\";\n      let j = inicio;\n      while (j < totalPalabras && (fragmento + palabras[j]).length <= maxLong) {\n        fragmento += (fragmento ? \" \" : \"\") + palabras[j];\n        j++;\n      }\n      if (fragmento.length >= minLong) {\n        if (fragmento[fragmento.length - 1] === \",\") fragmento = fragmento.slice(0, fragmento.length - 1);\n        return '\"' + fragmento + '...\"';\n      }\n    }\n\n    // Fallback: si no se encontró un fragmento bueno tras varios intentos\n    let fragmento = texto.slice(0, maxLong).split(\" \").slice(0, -1).join(\" \");\n    if (fragmento[fragmento.length - 1] === \",\") fragmento = fragmento.slice(0, fragmento.length - 1);\n    return '\"' + fragmento + '...\"';\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"extra-clues\",\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Pistas adicionales\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 70,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n      className: \"extra-clues-list\",\n      children: pistasDisponibles.map((pista, index) => {\n        const desbloqueada = fallos.length > index || acertado;\n        return /*#__PURE__*/_jsxDEV(\"li\", {\n          className: `clue-block ${desbloqueada ? \"unlocked\" : \"locked\"}`,\n          children: desbloqueada ? /*#__PURE__*/_jsxDEV(_Fragment, {\n            children: [\"\\uD83D\\uDD13 \", pista.type === 'component' ? pista.component : pista]\n          }, void 0, true) : `🔒 Pista ${index + 1}`\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 75,\n          columnNumber: 25\n        }, this);\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 71,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 69,\n    columnNumber: 9\n  }, this);\n};\n_c = ExtraClues;\nexport default ExtraClues;\nvar _c;\n$RefreshReg$(_c, \"ExtraClues\");","map":{"version":3,"names":["React","YouTubePlayer","jsxDEV","_jsxDEV","Fragment","_Fragment","ExtraClues","songData","fallos","acertado","_songData$song_name","_songData$song_name2","minStart","startTime","Math","floor","random","getVideoId","url","match","videoId","youtube_url","pistasDisponibles","final_place","paisAbajo","paisArriba","language","style","song_name","charAt","slice","obtenerFragmentoOptimizado","lyrics","artist_name","type","component","fileName","_jsxFileName","lineNumber","columnNumber","texto","minLong","maxLong","intentos","limpio","replace","trim","palabras","split","totalPalabras","length","i","inicio","fragmento","j","join","className","children","map","pista","index","desbloqueada","_c","$RefreshReg$"],"sources":["C:/Users/mpord/Documents/3IngSoft/2Cuatri/IU/UserInterfacesProject/Eurodle/src/guessSong/ExtraClues.js"],"sourcesContent":["import React from \"react\";\r\nimport YouTubePlayer from './YouTubePlayer'; // Adjust the import path\r\n\r\nconst ExtraClues = ({ songData, fallos, acertado }) => {\r\n    if (!songData) return null;\r\n\r\n    const minStart = 6;\r\n    const startTime = Math.floor(Math.random() * (100 - minStart)) + minStart;\r\n\r\n    // Extract video ID from YouTube URL\r\n    const getVideoId = (url) => {\r\n        if (!url) return '';\r\n        const match = url.match(/(?:youtu\\.be\\/|youtube\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=))([^?&]+)/i);\r\n        return match && match[1] ? match[1] : '';\r\n    };\r\n\r\n    const videoId = getVideoId(songData.youtube_url);\r\n\r\n    const pistasDisponibles = [\r\n\r\n        `Ranking final: ${\"la canción quedó en el puesto \"+songData.final_place}`,\r\n\r\n        `${\"la canción quedó\" + (songData.paisAbajo===\"Desconocido\"? \"\" : \" por encima de \" + songData.paisAbajo) +\r\n        (songData.paisAbajo===\"Desconocido\" || songData.paisArriba===\"Desconocido\"? \"\" : \" y \") +\r\n        (songData.paisArriba===\"Desconocido\"? \"\" : \"y por debajo de \" + songData.paisArriba)}`,\r\n\r\n        `${\"El idioma del tema es: \" + songData.language + \" y el género: \" + songData.style}`,\r\n\r\n        `El nombre de la canción empieza con la letra: ${songData.song_name?.charAt(0)} y termina con: ${songData.song_name?.slice(-1)}`,\r\n\r\n        `Fragmento de la letra: ${obtenerFragmentoOptimizado(songData.lyrics)}`,\r\n\r\n        `${\"Nombre del/los artista/s o del grupo: \" + songData.artist_name}`,\r\n\r\n        { type: 'component', component: <YouTubePlayer videoId={videoId} startTime={startTime} /> },\r\n    ];\r\n\r\n    function obtenerFragmentoOptimizado(texto, minLong = 70, maxLong = 100, intentos = 10) {\r\n        const limpio = texto\r\n            .replace(/(\\\\n\\s*){1,}/g, \", \")  // Agrupa 1 o más \\n seguidos como una coma\r\n            .replace(/\\s+/g, \" \")            // Normaliza los espacios\r\n            .trim();\r\n        const palabras = limpio.split(\" \");\r\n        const totalPalabras = palabras.length;\r\n\r\n        for (let i = 0; i < intentos; i++) {\r\n            let inicio = Math.floor(Math.random() * totalPalabras);\r\n            let fragmento = \"\";\r\n            let j = inicio;\r\n\r\n            while (j < totalPalabras && (fragmento + palabras[j]).length <= maxLong) {\r\n                fragmento += (fragmento ? \" \" : \"\") + palabras[j];\r\n                j++;\r\n            }\r\n\r\n            if (fragmento.length >= minLong) {\r\n                if(fragmento[fragmento.length-1] === \",\") fragmento = fragmento.slice(0, fragmento.length-1)\r\n                return '\"' + fragmento + '...\"';\r\n            }\r\n        }\r\n\r\n        // Fallback: si no se encontró un fragmento bueno tras varios intentos\r\n        let fragmento = texto.slice(0, maxLong).split(\" \").slice(0, -1).join(\" \");\r\n        if(fragmento[fragmento.length-1] === \",\") fragmento = fragmento.slice(0, fragmento.length-1)\r\n        return '\"' + fragmento + '...\"';\r\n    }\r\n\r\n    return (\r\n        <div className=\"extra-clues\">\r\n            <h2>Pistas adicionales</h2>\r\n            <ul className=\"extra-clues-list\">\r\n                {pistasDisponibles.map((pista, index) => {\r\n                    const desbloqueada = fallos.length > index || acertado;\r\n                    return (\r\n                        <li key={index} className={`clue-block ${desbloqueada ? \"unlocked\" : \"locked\"}`}>\r\n                            {desbloqueada ? (\r\n                                <>\r\n                                    🔓 {pista.type === 'component' ? pista.component : pista}\r\n                                </>\r\n                            ) : (\r\n                                `🔒 Pista ${index + 1}`\r\n                            )}\r\n                        </li>\r\n                    );\r\n                })}\r\n            </ul>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default ExtraClues;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}